/**
 * Copyright 1&1 Internet AG, https://github.com/1and1/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.oneandone.sales.tools.stool.util;

import net.oneandone.sushi.fs.Copy;
import net.oneandone.sushi.fs.ModeException;
import net.oneandone.sushi.fs.Node;
import net.oneandone.sushi.fs.filter.Filter;
import net.oneandone.sushi.util.Substitution;

import java.io.IOException;
import java.nio.file.attribute.GroupPrincipal;
import java.util.Map;

public final class Files {
    public static final Substitution S = new Substitution("${{", "}}", '\\');

    public static void template(Node src, Node dest, Map<String, String> variables) throws IOException {
        Copy template;
        Filter selection;

        // Permissions:
        //
        // template files are stool files, but some of the directories may contain none-stool files
        // (e.g. tomcat/conf/Catalina). So we cannot remove the whole directory to create a fresh copy
        // (also, we would loose log files by wiping the template) and we cannot simply update permissions
        // for all files in the directory recursively
        selection = src.getWorld().filter().includeAll();
        template = new Copy(src, withoutBinary(selection), false, variables, S);
        for (Node node : template.directory(dest)) {
            Files.stoolNode(node);
        }
        for (Node binary : src.find(selection)) {
            if (isBinary(binary.getName())) {
                Files.stoolFile(binary.copyFile(dest.join(binary.getRelative(src))));
            }
        }
    }

    //--

    /** files without keyword substitution */
    private static final String[] BINARY_EXTENSIONS = {".keystore", ".war", ".jar", ".gif", ".ico", ".class "};

    public static boolean isBinary(String name) {
        for (String ext : BINARY_EXTENSIONS) {
            if (name.endsWith(ext)) {
                return true;
            }
        }
        return false;
    }

    private static Filter withoutBinary(Filter orig) {
        Filter result;

        result = new Filter(orig);
        for (String ext : BINARY_EXTENSIONS) {
            result.exclude("**/*" + ext);
        }
        return result;
    }

    //--
    //
    // The method below adjust file permisions.
    //
    // To think about permissions, it's useful to distinguishes three types for files/directories
    // * source files
    //   almost everything in the stage directory; this includes the files generated by the build process (usually
    //   in the target directory
    // * application files
    //   everything written by the running application, e.g. log files; usually, application files are written under
    //   the wrapper directory, but also file accidentally written into the target directory are also includes files
    //   are application files; also, when tomcat writes files, they are application files (e.g
    //   tomcat/conf/Catalina). If the application can change source files with an built-in editor, these files
    //   are considered source files, even though they were changed by the application
    // * stool files
    //   everything written by stool - in particular file to configure the application. All stool files reside in
    //   the wrapper directory, stool does not modify the stage directory. (There is one exception from thus rule:
    //   projects/servletconf/tomcat for directory stages).
    //
    // Its useful to distinguish 2 users:
    // * owner
    //   the stage owner. Only he may change source file, and he is the owner of application files.
    // * other
    //   another user who may use stool; he can modify stool files e.g. to start a stage, but he cannot modify source
    //   files or application files.
    //
    public static void stoolNode(Node node) throws IOException {
        if (node.isDirectory()) {
            stoolDirectory(node);
        } else if (node.getName().endsWith(".sh")) {
            stoolExecutable(node);
        } else {
            stoolFile(node);
        }
    }

    /** set permissions of a file that may be modified by any user */
    public static void stoolFile(Node file) throws IOException {
        permissions(file, "rw-rw-rw-");
    }

    public static void stoolExecutable(Node file) throws IOException {
        permissions(file, "rwxrwxr-x");
    }

    public static void stoolDirectory(Node file) throws IOException {
        permissions(file, "rwxrwxr-x");
    }

    public static void waterlooFile(Node file, final GroupPrincipal group) throws IOException {
        stoolFile(file);
        permissions(file, "r--rwxr--");
        file.setGroup(group);
    }


    private static void permissions(Node file, String str) throws IOException {
        String existing;

        existing = file.getPermissions();
        if (!existing.equals(str)) {
            try {
                file.setPermissions(str);
            } catch (ModeException e) {
                throw new IOException(file.toString() + ": cannot updated permissions from " + existing + " to " + str, e);
            }
        }
    }

    private Files() {
    }
}
