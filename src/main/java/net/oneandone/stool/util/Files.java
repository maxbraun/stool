/**
 * Copyright 1&1 Internet AG, https://github.com/1and1/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package net.oneandone.stool.util;

import net.oneandone.sushi.fs.Copy;
import net.oneandone.sushi.fs.ModeException;
import net.oneandone.sushi.fs.Node;
import net.oneandone.sushi.fs.file.FileNode;
import net.oneandone.sushi.fs.filter.Filter;
import net.oneandone.sushi.util.Separator;
import net.oneandone.sushi.util.Substitution;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;

public final class Files {
    public static final Substitution S = new Substitution("${{", "}}", '\\');

    public static void template(PrintWriter log, Node src, FileNode dest, Map<String, String> variables) throws IOException {
        Filter selection;

        // Permissions:
        //
        // template files are stool files, but some of the directories may contain none-stool files
        // (e.g. tomcat/conf/Catalina). So we cannot remove the whole directory to create a fresh copy
        // (also, we would loose log files by wiping the template) and we cannot simply update permissions
        // for all files in the directory recursively
        selection = src.getWorld().filter().includeAll();
        new Copy(src, withoutBinary(selection), false, variables, S).directory(dest);
        Files.backstageTree(log, dest);
        for (Node file : dest.find("**/*.sh")) {
            backstageExecutable(file);
        }
        for (Node binary : src.find(selection)) {
            if (isBinary(binary.getName())) {
                Files.backstageFile(binary.copyFile(dest.join(binary.getRelative(src))));
            }
        }
    }

    public static void backstageTree(PrintWriter log, FileNode dir) throws IOException {
        Files.backstageDirectory(log, dir);
        for (FileNode child : dir.list()) {
            if (child.isDirectory()) {
                backstageTree(log, child);
            } else {
                backstageFile(child);
            }
        }
    }

    //--

    /** files without keyword substitution */
    private static final String[] BINARY_EXTENSIONS = {".keystore", ".war", ".jar", ".gif", ".ico", ".class "};

    public static boolean isBinary(String name) {
        for (String ext : BINARY_EXTENSIONS) {
            if (name.endsWith(ext)) {
                return true;
            }
        }
        return false;
    }

    private static Filter withoutBinary(Filter orig) {
        Filter result;

        result = new Filter(orig);
        for (String ext : BINARY_EXTENSIONS) {
            result.exclude("**/*" + ext);
        }
        return result;
    }

    //--
    //
    // The method below adjust file permisions.
    //
    // To think about permissions, it's useful to distinguishes three types for files/directories
    // * source files
    //   almost everything in the stage directory; this includes the files generated by the build process (usually
    //   in the target directory
    // * application files
    //   everything written by the running application, e.g. log files; usually, application files are written under
    //   the backstage directory, but also file accidentally written into the target directory are also includes files
    //   are application files; also, when tomcat writes files, they are application files (e.g
    //   tomcat/conf/Catalina). If the application can change source files with an built-in editor, these files
    //   are considered source files, even though they were changed by the application
    // * stool files
    //   everything written by stool - in particular file to configure the application. All stool files reside in
    //   the backstage directory, stool does not modify the stage directory. (There is one exception from thus rule:
    //   projects/servletconf/tomcat for directory stages).
    //
    // Its useful to distinguish 2 users:
    // * owner
    //   the stage owner. Only he may change source file, and he is the owner of application files.
    // * other
    //   another user who may use stool; he can modify stool files e.g. to start a stage, but he cannot modify source
    //   files or application files.
    //

    /** set permissions of a file that may be modified by any user */
    public static Node backstageFile(Node file) throws IOException {
        permissions(file, "rw-rw-rw-");
        return file;
    }

    private static Node backstageExecutable(Node file) throws IOException {
        permissions(file, "rwxrwxr-x");
        return file;
    }

    private static Node backstageDirectory(PrintWriter log, Node directory) throws IOException {
        permissions(directory, "rwxrwxr-x");
        // TODO: this is expensive, but otherwise, the setgid bit inherited from the home directory is lost by the previous permissions call.
        setgid(log, (FileNode) directory);
        return directory;
    }

    public static void setgid(PrintWriter log, FileNode dir) throws IOException {
        exec(log, dir, "chmod", "g+s", ".");
    }

    public static Node createBackstageDirectoryOpt(PrintWriter log, FileNode directory) throws IOException {
        if (!directory.isDirectory()) {
            createBackstageDirectory(log, directory);
        }
        return directory;
    }

    /** creates a directory with mode 2775: writable for everybody in the group, with setgid. */
    public static Node createBackstageDirectory(PrintWriter log, FileNode directory) throws IOException {
        // java.nio.file has code to set posix permissions, but not setgid (they even overwrite the setgid bit
        exec(log, directory.getParent(), "mkdir", "-m", "2775", directory.getName());
        return directory;
    }

    /** Creates a directory that's readable for all stool group users. */
    public static void createStageDirectory(PrintWriter log, FileNode dir, String group) throws IOException {
        dir.mkdir();
        exec(log, dir, "chgrp", group, dir.getAbsolute()); // . would be fine, but absolute path yields better exceptions
        setgid(log, dir);
    }

    private static void permissions(Node file, String str) throws IOException {
        String existing;

        existing = file.getPermissions();
        if (!existing.equals(str)) {
            try {
                file.setPermissions(str);
            } catch (ModeException e) {
                throw new IOException(file.toString() + ": cannot updated permissions from " + existing + " to " + str, e);
            }
        }
    }

    public static void fixPermissions(PrintWriter log, FileNode dir, String group) throws IOException {
        exec(log, dir, "chgrp", "-R", group, ".");
        exec(log, dir, "sh", "-c", "find . -type d | xargs chmod g+s");
    }

    public static void exec(PrintWriter log, FileNode home, String ... cmd) throws IOException {
        log.println("[" + home + "] " + Separator.SPACE.join(cmd));
        home.execNoOutput(cmd);
    }

    private Files() {
    }

}
